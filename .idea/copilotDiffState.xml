<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.google.ksp)&#10;    // add the kotlinx serialization plugin to handle the json data&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;1.9.21&quot;&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.faiz.trekandtrack&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.faiz.trekandtrack&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 2&#10;        versionName = &quot;1.0.1&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // AndroidX &amp; Core&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Jetpack Compose&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.material.icons.extended)&#10;&#10;    // Navigation&#10;    implementation(libs.androidx.navigation.compose)&#10;&#10;    // Room Database&#10;    implementation(libs.bundles.androidx.room)&#10;    ksp(libs.androidx.room.compiler)&#10;&#10;    // DataStore for preferences&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // Coil - Image Loading Library for Compose&#10;    implementation(&quot;io.coil-kt:coil-compose:2.5.0&quot;)&#10;&#10;    //----Additions for networking&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;) // The core library for making network requests to your backend&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0&quot;) // The library for converting Kotlin objects to and from JSON.&#10;    implementation(&quot;com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0&quot;) // A converter that allows retrofit to use kotlinx Serialization&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;) // A utility to log network request and response details, which is very helpful for debugging&#10;&#10;    //splash screen - removed the androidx.core:core-splashscreen library to avoid drawable issues&#10;    //implementation(&quot;androidx.core:core-splashscreen:1.0.1&quot;)&#10;&#10;    //Apache POI for Excel export&#10;    implementation(&quot;org.apache.poi:poi:5.2.3&quot;)&#10;    implementation(&quot;org.apache.poi:poi-ooxml:5.2.3&quot;)&#10;&#10;    //For advanced pdfs&#10;    //implementation(&quot;com.itextpdf:itext7-core:7.2.5&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.google.ksp)&#10;    // add the kotlinx serialization plugin to handle the json data&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;1.9.21&quot;&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.faiz.trekandtrack&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.faiz.trekandtrack&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 2&#10;        versionName = &quot;1.0.1&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // AndroidX &amp; Core&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Jetpack Compose&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.material.icons.extended)&#10;&#10;    // Navigation&#10;    implementation(libs.androidx.navigation.compose)&#10;&#10;    // Room Database&#10;    implementation(libs.bundles.androidx.room)&#10;    ksp(libs.androidx.room.compiler)&#10;&#10;    // DataStore for preferences&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // Coil - Image Loading Library for Compose&#10;    implementation(&quot;io.coil-kt:coil-compose:2.5.0&quot;)&#10;&#10;    //----Additions for networking&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;) // The core library for making network requests to your backend&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0&quot;) // The library for converting Kotlin objects to and from JSON.&#10;    implementation(&quot;com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0&quot;) // A converter that allows retrofit to use kotlinx Serialization&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;) // A utility to log network request and response details, which is very helpful for debugging&#10;&#10;    // Moshi for JSON parsing (for exchange rate API)&#10;    implementation(&quot;com.squareup.moshi:moshi:1.15.0&quot;)&#10;    implementation(&quot;com.squareup.moshi:moshi-kotlin:1.15.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-moshi:2.9.0&quot;)&#10;    ksp(&quot;com.squareup.moshi:moshi-kotlin-codegen:1.15.0&quot;)&#10;&#10;    //splash screen - removed the androidx.core:core-splashscreen library to avoid drawable issues&#10;    //implementation(&quot;androidx.core:core-splashscreen:1.0.1&quot;)&#10;&#10;    //Apache POI for Excel export&#10;    implementation(&quot;org.apache.poi:poi:5.2.3&quot;)&#10;    implementation(&quot;org.apache.poi:poi-ooxml:5.2.3&quot;)&#10;&#10;    //For advanced pdfs&#10;    //implementation(&quot;com.itextpdf:itext7-core:7.2.5&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/Data/4_Database.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/Data/4_Database.kt" />
              <option name="originalContent" value="package com.example.expensecalculator.Data&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import com.example.expensecalculator.tripData.ExpenseSplit // --- 1. ADD: Import for the new entity&#10;import com.example.expensecalculator.tripData.Trip&#10;import com.example.expensecalculator.tripData.TripDao&#10;import com.example.expensecalculator.tripData.TripExpense&#10;import com.example.expensecalculator.tripData.TripParticipant&#10;import com.example.expensecalculator.tripData.TripPhoto&#10;import com.example.expensecalculator.tripData.SettlementPayment // --- 2. ADD: Import for the SettlementPayment entity&#10;import java.util.Date&#10;&#10;@TypeConverters(Converters::class)&#10;@Database(&#10;    entities = [&#10;        Account::class,&#10;        Expense::class,&#10;        Trip::class,&#10;        TripParticipant::class,&#10;        TripExpense::class,&#10;        ExpenseSplit::class,&#10;        TripPhoto::class,&#10;        SettlementPayment::class // --- 3. ADD: SettlementPayment entity to the database&#10;    ],&#10;    version = 13, // --- 4. Increment version to 13&#10;    exportSchema = false&#10;)&#10;abstract class ExpenseDatabase : RoomDatabase() {&#10;&#10;    abstract fun accountDao(): AccountDao&#10;    abstract fun expenseDao(): ExpenseDao&#10;    abstract fun tripDao(): TripDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: ExpenseDatabase? = null&#10;&#10;        fun getDatabase(context: Context): ExpenseDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    ExpenseDatabase::class.java,&#10;                    &quot;expense_db&quot;&#10;                ).fallbackToDestructiveMigration().build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class Converters {&#10;    @androidx.room.TypeConverter&#10;    fun fromTimestamp(value: Long?): Date? {&#10;        return value?.let { Date(it) }&#10;    }&#10;&#10;    @androidx.room.TypeConverter&#10;    fun dateToTimestamp(date: Date?): Long? {&#10;        return date?.time&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.expensecalculator.Data&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import com.example.expensecalculator.tripData.ExpenseSplit // --- 1. ADD: Import for the new entity&#10;import com.example.expensecalculator.tripData.Trip&#10;import com.example.expensecalculator.tripData.TripDao&#10;import com.example.expensecalculator.tripData.TripExpense&#10;import com.example.expensecalculator.tripData.TripParticipant&#10;import com.example.expensecalculator.tripData.TripPhoto&#10;import com.example.expensecalculator.tripData.SettlementPayment // --- 2. ADD: Import for the SettlementPayment entity&#10;import java.util.Date&#10;&#10;@TypeConverters(Converters::class)&#10;@Database(&#10;    entities = [&#10;        Account::class,&#10;        Expense::class,&#10;        Trip::class,&#10;        TripParticipant::class,&#10;        TripExpense::class,&#10;        ExpenseSplit::class,&#10;        TripPhoto::class,&#10;        SettlementPayment::class // --- 3. ADD: SettlementPayment entity to the database&#10;    ],&#10;    version = 14, // --- 4. Increment version to 14&#10;    exportSchema = false&#10;)&#10;abstract class ExpenseDatabase : RoomDatabase() {&#10;&#10;    abstract fun accountDao(): AccountDao&#10;    abstract fun expenseDao(): ExpenseDao&#10;    abstract fun tripDao(): TripDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: ExpenseDatabase? = null&#10;&#10;        fun getDatabase(context: Context): ExpenseDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    ExpenseDatabase::class.java,&#10;                    &quot;expense_db&quot;&#10;                ).fallbackToDestructiveMigration().build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class Converters {&#10;    @androidx.room.TypeConverter&#10;    fun fromTimestamp(value: Long?): Date? {&#10;        return value?.let { Date(it) }&#10;    }&#10;&#10;    @androidx.room.TypeConverter&#10;    fun dateToTimestamp(date: Date?): Long? {&#10;        return date?.time&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/TripManager/18_TripRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/TripManager/18_TripRepository.kt" />
              <option name="originalContent" value="package com.example.expensecalculator.TripManager&#10;&#10;import com.example.expensecalculator.tripData.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;class TripRepository(private val tripDao: TripDao) {&#10;&#10;    fun getAllTrips(): Flow&lt;List&lt;Trip&gt;&gt; = tripDao.showAllTrips()&#10;&#10;    suspend fun deleteTripCompletely(trip: Trip) {&#10;        tripDao.deleteTripCompletely(trip)&#10;    }&#10;&#10;    suspend fun addTripWithParticipants(title: String, participantNames: List&lt;String&gt;, tripIconUri: String? = null) {&#10;        val newTrip = Trip(title = title, tripIconUri = tripIconUri)&#10;        tripDao.addTripWithParticipants(newTrip, participantNames)&#10;    }&#10;&#10;    suspend fun updateTripWithParticipants(tripId: Int, title: String, participantNames: List&lt;String&gt;, tripIconUri: String? = null) {&#10;        // First, get the existing trip to preserve other details like days/budget&#10;        val existingTrip = getCompleteTripDetails(tripId)?.trip ?: Trip(id = tripId, title = title)&#10;        val tripToUpdate = existingTrip.copy(title = title, tripIconUri = tripIconUri ?: existingTrip.tripIconUri)&#10;        tripDao.updateTripWithParticipants(tripToUpdate, participantNames)&#10;    }&#10;&#10;    suspend fun getCompleteTripDetails(tripId: Int): CompleteTripDetails? {&#10;        return tripDao.getCompleteTripDetails(tripId)&#10;    }&#10;&#10;    fun getCompleteTripDetailsFlow(tripId: Int): Flow&lt;CompleteTripDetails?&gt; {&#10;        return tripDao.getCompleteTripDetailsFlow(tripId)&#10;    }&#10;&#10;    //  Update trip icon&#10;    suspend fun updateTripIcon(tripId: Int, iconUri: String) {&#10;        val existingTrip = getCompleteTripDetails(tripId)?.trip ?: return&#10;        val updatedTrip = existingTrip.copy(tripIconUri = iconUri)&#10;        tripDao.updateTrip(updatedTrip)&#10;    }&#10;&#10;    // This now calls the new transaction in the DAO&#10;    suspend fun addExpenseWithSplits(expense: TripExpense, splits: List&lt;ExpenseSplit&gt;) {&#10;        tripDao.addExpenseWithSplits(expense, splits)&#10;    }&#10;&#10;    suspend fun deleteExpense(expense: TripExpense) {&#10;        tripDao.deleteExpense(expense)&#10;    }&#10;&#10;    // Get a single expense with its splits&#10;    fun getExpenseWithSplitsById(expenseId: Int): Flow&lt;ExpenseWithSplits?&gt; {&#10;        return tripDao.getExpenseWithSplitsByIdFlow(expenseId)&#10;    }&#10;&#10;    //PHOTO OPERATIONS&#10;    suspend fun addPhoto(photo: TripPhoto): Long {&#10;        return tripDao.addPhoto(photo)&#10;    }&#10;&#10;    suspend fun deletePhoto(photo: TripPhoto) {&#10;        tripDao.deletePhoto(photo)&#10;    }&#10;&#10;    fun getPhotosByTripId(tripId: Int): Flow&lt;List&lt;TripPhoto&gt;&gt; {&#10;        return tripDao.getPhotosByTripIdFlow(tripId)&#10;    }&#10;&#10;    // SETTLEMENT PAYMENT OPERATIONS&#10;    suspend fun addSettlementPayment(payment: SettlementPayment): Long {&#10;        return tripDao.addSettlementPayment(payment)&#10;    }&#10;&#10;    suspend fun deleteSettlementPayment(payment: SettlementPayment) {&#10;        tripDao.deleteSettlementPayment(payment)&#10;    }&#10;&#10;    fun getSettlementPaymentsByTripId(tripId: Int): Flow&lt;List&lt;SettlementPayment&gt;&gt; {&#10;        return tripDao.getSettlementPaymentsByTripIdFlow(tripId)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.expensecalculator.TripManager&#10;&#10;import com.example.expensecalculator.tripData.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;class TripRepository(private val tripDao: TripDao) {&#10;&#10;    fun getAllTrips(): Flow&lt;List&lt;Trip&gt;&gt; = tripDao.showAllTrips()&#10;&#10;    suspend fun deleteTripCompletely(trip: Trip) {&#10;        tripDao.deleteTripCompletely(trip)&#10;    }&#10;&#10;    suspend fun addTripWithParticipants(title: String, participantNames: List&lt;String&gt;, tripIconUri: String? = null) {&#10;        val newTrip = Trip(title = title, tripIconUri = tripIconUri)&#10;        tripDao.addTripWithParticipants(newTrip, participantNames)&#10;    }&#10;&#10;    suspend fun updateTripWithParticipants(tripId: Int, title: String, participantNames: List&lt;String&gt;, tripIconUri: String? = null) {&#10;        // First, get the existing trip to preserve other details like days/budget&#10;        val existingTrip = getCompleteTripDetails(tripId)?.trip ?: Trip(id = tripId, title = title)&#10;        val tripToUpdate = existingTrip.copy(title = title, tripIconUri = tripIconUri ?: existingTrip.tripIconUri)&#10;        tripDao.updateTripWithParticipants(tripToUpdate, participantNames)&#10;    }&#10;&#10;    suspend fun getCompleteTripDetails(tripId: Int): CompleteTripDetails? {&#10;        return tripDao.getCompleteTripDetails(tripId)&#10;    }&#10;&#10;    fun getCompleteTripDetailsFlow(tripId: Int): Flow&lt;CompleteTripDetails?&gt; {&#10;        return tripDao.getCompleteTripDetailsFlow(tripId)&#10;    }&#10;&#10;    //  Update trip icon&#10;    suspend fun updateTripIcon(tripId: Int, iconUri: String) {&#10;        val existingTrip = getCompleteTripDetails(tripId)?.trip ?: return&#10;        val updatedTrip = existingTrip.copy(tripIconUri = iconUri)&#10;        tripDao.updateTrip(updatedTrip)&#10;    }&#10;&#10;    // This now calls the new transaction in the DAO&#10;    suspend fun addExpenseWithSplits(expense: TripExpense, splits: List&lt;ExpenseSplit&gt;) {&#10;        tripDao.addExpenseWithSplits(expense, splits)&#10;    }&#10;&#10;    suspend fun deleteExpense(expense: TripExpense) {&#10;        tripDao.deleteExpense(expense)&#10;    }&#10;&#10;    // Get a single expense with its splits&#10;    fun getExpenseWithSplitsById(expenseId: Int): Flow&lt;ExpenseWithSplits?&gt; {&#10;        return tripDao.getExpenseWithSplitsByIdFlow(expenseId)&#10;    }&#10;&#10;    //PHOTO OPERATIONS&#10;    suspend fun addPhoto(photo: TripPhoto): Long {&#10;        return tripDao.addPhoto(photo)&#10;    }&#10;&#10;    suspend fun deletePhoto(photo: TripPhoto) {&#10;        tripDao.deletePhoto(photo)&#10;    }&#10;&#10;    fun getPhotosByTripId(tripId: Int): Flow&lt;List&lt;TripPhoto&gt;&gt; {&#10;        return tripDao.getPhotosByTripIdFlow(tripId)&#10;    }&#10;&#10;    // SETTLEMENT PAYMENT OPERATIONS&#10;    suspend fun addSettlementPayment(payment: SettlementPayment): Long {&#10;        return tripDao.addSettlementPayment(payment)&#10;    }&#10;&#10;    suspend fun deleteSettlementPayment(payment: SettlementPayment) {&#10;        tripDao.deleteSettlementPayment(payment)&#10;    }&#10;&#10;    fun getSettlementPaymentsByTripId(tripId: Int): Flow&lt;List&lt;SettlementPayment&gt;&gt; {&#10;        return tripDao.getSettlementPaymentsByTripIdFlow(tripId)&#10;    }&#10;&#10;    // CURRENCY OPERATIONS&#10;    suspend fun updateTripCurrency(tripId: Int, currency: String) {&#10;        tripDao.updateTripCurrency(tripId, currency)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/TripManager/19_TripViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/TripManager/19_TripViewModel.kt" />
              <option name="originalContent" value="package com.example.expensecalculator.TripManager&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.os.Build&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.expensecalculator.Storage.ExportFormat&#10;import com.example.expensecalculator.tripData.CompleteTripDetails&#10;import com.example.expensecalculator.tripData.ExpenseSplit&#10;import com.example.expensecalculator.tripData.ExpenseWithSplits&#10;import com.example.expensecalculator.tripData.SettlementPayment&#10;import com.example.expensecalculator.tripData.Trip&#10;import com.example.expensecalculator.tripData.TripExpense&#10;import com.example.expensecalculator.tripData.TripParticipant&#10;import com.example.expensecalculator.tripData.TripPhoto&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;class TripViewModel(&#10;    private val repository: TripRepository,&#10;    context: Context&#10;) : ViewModel() {&#10;&#10;    private val exportManager = TripExportManager(context.applicationContext)&#10;&#10;    val allTrips = repository.getAllTrips()&#10;&#10;    private val _completeTripDetails = MutableStateFlow&lt;CompleteTripDetails?&gt;(null)&#10;    val completeTripDetails: StateFlow&lt;CompleteTripDetails?&gt; = _completeTripDetails.asStateFlow()&#10;&#10;    val currentTripExpenses: StateFlow&lt;List&lt;TripExpense&gt;&gt; = _completeTripDetails.map {&#10;        it?.expensesWithSplits?.map { expenseWithSplits -&gt; expenseWithSplits.expense } ?: emptyList()&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;    val currentTripParticipants: StateFlow&lt;List&lt;TripParticipant&gt;&gt; = _completeTripDetails.map {&#10;        it?.participants ?: emptyList()&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;&#10;&#10;    val tripBalances: StateFlow&lt;Map&lt;String, Double&gt;&gt; = _completeTripDetails.map { details -&gt;&#10;        if (details == null) {&#10;            emptyMap()&#10;        } else {&#10;            val balances = mutableMapOf&lt;String, Double&gt;()&#10;            // 1. Initialize balances for all participants to 0&#10;            details.participants.forEach { participant -&gt;&#10;                balances[participant.participantName] = 0.0&#10;            }&#10;&#10;            // 2. Process each expense&#10;            details.expensesWithSplits.forEach { expenseWithSplits -&gt;&#10;                val expense = expenseWithSplits.expense&#10;                val paidBy = expense.paidBy&#10;                val totalAmount = expense.amount&#10;&#10;                // Add the full amount to the person who paid&#10;                balances[paidBy] = (balances[paidBy] ?: 0.0) + totalAmount&#10;&#10;                // Subtract each person's share from their balance&#10;                expenseWithSplits.splits.forEach { split -&gt;&#10;                    val participantName = split.participantName&#10;                    val shareAmount = split.shareAmount&#10;                    balances[participantName] = (balances[participantName] ?: 0.0) - shareAmount&#10;                }&#10;            }&#10;            balances&#10;        }&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyMap())&#10;&#10;    // Settlement payments for current trip&#10;    private val _settlementPayments = MutableStateFlow&lt;List&lt;SettlementPayment&gt;&gt;(emptyList())&#10;    val settlementPayments: StateFlow&lt;List&lt;SettlementPayment&gt;&gt; = _settlementPayments.asStateFlow()&#10;&#10;    // Adjusted balances after settlement payments&#10;    val adjustedBalances: StateFlow&lt;Map&lt;String, Double&gt;&gt; = tripBalances.map { baseBalances -&gt;&#10;        val adjusted = baseBalances.toMutableMap()&#10;        _settlementPayments.value.forEach { payment -&gt;&#10;            adjusted[payment.fromParticipant] = (adjusted[payment.fromParticipant] ?: 0.0) + payment.amount&#10;            adjusted[payment.toParticipant] = (adjusted[payment.toParticipant] ?: 0.0) - payment.amount&#10;        }&#10;        adjusted&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyMap())&#10;&#10;    // Optimized settlements calculated from adjusted balances&#10;    val optimizedSettlements: StateFlow&lt;List&lt;Settlement&gt;&gt; = adjustedBalances.map { balances -&gt;&#10;        SettlementOptimizer.calculateOptimizedSettlements(balances)&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;&#10;    fun saveTrip(tripId: Int?, title: String, participantNames: List&lt;String&gt;, tripIconUri: String? = null) {&#10;        viewModelScope.launch {&#10;            if (tripId == null || tripId == -1) {&#10;                repository.addTripWithParticipants(title, participantNames, tripIconUri)&#10;            } else {&#10;                repository.updateTripWithParticipants(tripId, title, participantNames, tripIconUri)&#10;            }&#10;        }&#10;    }&#10;&#10;    //  Update trip icon&#10;    fun updateTripIcon(tripId: Int, iconUri: String) {&#10;        viewModelScope.launch {&#10;            repository.updateTripIcon(tripId, iconUri)&#10;        }&#10;    }&#10;&#10;    suspend fun getTripById(tripId: Int): CompleteTripDetails? {&#10;        return repository.getCompleteTripDetails(tripId)&#10;    }&#10;&#10;    fun deleteTripCompletely(trip: Trip) {&#10;        viewModelScope.launch {&#10;            repository.deleteTripCompletely(trip)&#10;        }&#10;    }&#10;&#10;    fun setCurrentTrip(tripId: Int) {&#10;        viewModelScope.launch {&#10;            repository.getCompleteTripDetailsFlow(tripId).collect { details -&gt;&#10;                _completeTripDetails.value = details&#10;            }&#10;        }&#10;        loadSettlementPayments(tripId)&#10;    }&#10;&#10;    fun clearCurrentTrip() {&#10;        _completeTripDetails.value = null&#10;    }&#10;&#10;    fun addExpense(&#10;        expenseName: String,&#10;        amount: Double,&#10;        paidBy: String,&#10;        participantsInSplit: List&lt;String&gt;&#10;    ) {&#10;        val tripId = _completeTripDetails.value?.trip?.id ?: return&#10;        val currentDate = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;&#10;        viewModelScope.launch {&#10;            val expense = TripExpense(&#10;                tripId = tripId,&#10;                expenseName = expenseName,&#10;                amount = amount,&#10;                paidBy = paidBy,&#10;                date = currentDate&#10;            )&#10;&#10;            val shareAmount = amount / participantsInSplit.size&#10;            val splits = participantsInSplit.map { participantName -&gt;&#10;                ExpenseSplit(&#10;                    expenseId = 0, // This will be set by the DAO&#10;                    participantName = participantName,&#10;                    shareAmount = shareAmount&#10;                )&#10;            }&#10;            repository.addExpenseWithSplits(expense, splits)&#10;        }&#10;    }&#10;&#10;    fun deleteExpense(expense: TripExpense) {&#10;        viewModelScope.launch {&#10;            repository.deleteExpense(expense)&#10;        }&#10;    }&#10;&#10;    fun getExpenseWithSplitsById(expenseId: Int): StateFlow&lt;ExpenseWithSplits?&gt; {&#10;        return repository.getExpenseWithSplitsById(expenseId)&#10;            .stateIn(viewModelScope, SharingStarted.Lazily, null)&#10;    }&#10;&#10;&#10;    val currentTripPhotos: StateFlow&lt;List&lt;TripPhoto&gt;&gt; = _completeTripDetails.map {&#10;        it?.photos ?: emptyList()&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;    fun addPhoto(photoUri: String, caption: String? = null) {&#10;        val tripId = _completeTripDetails.value?.trip?.id ?: return&#10;        viewModelScope.launch {&#10;            val photo = TripPhoto(&#10;                tripId = tripId,&#10;                photoUri = photoUri,&#10;                caption = caption&#10;            )&#10;            repository.addPhoto(photo)&#10;        }&#10;    }&#10;&#10;    fun deletePhoto(photo: TripPhoto) {&#10;        viewModelScope.launch {&#10;            repository.deletePhoto(photo)&#10;        }&#10;    }&#10;&#10;    // SETTLEMENT PAYMENT OPERATIONS&#10;    fun addSettlementPayment(fromParticipant: String, toParticipant: String, amount: Double) {&#10;        val tripId = _completeTripDetails.value?.trip?.id ?: return&#10;        val currentDate = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;&#10;        viewModelScope.launch {&#10;            val payment = SettlementPayment(&#10;                tripId = tripId,&#10;                fromParticipant = fromParticipant,&#10;                toParticipant = toParticipant,&#10;                amount = amount,&#10;                date = currentDate&#10;            )&#10;            repository.addSettlementPayment(payment)&#10;        }&#10;    }&#10;&#10;    fun deleteSettlementPayment(payment: SettlementPayment) {&#10;        viewModelScope.launch {&#10;            repository.deleteSettlementPayment(payment)&#10;        }&#10;    }&#10;&#10;    private fun loadSettlementPayments(tripId: Int) {&#10;        viewModelScope.launch {&#10;            repository.getSettlementPaymentsByTripId(tripId).collect { payments -&gt;&#10;                _settlementPayments.value = payments&#10;            }&#10;        }&#10;    }&#10;&#10;    //EXPORT OPERATIONS&#10;    fun exportTrip(format: ExportFormat, onComplete: (Uri?) -&gt; Unit) {&#10;        // Check if Android version supports the export functionality&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) {&#10;            onComplete(null)&#10;            return&#10;        }&#10;&#10;        val tripDetails = _completeTripDetails.value ?: run {&#10;            onComplete(null)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            val uri = when (format) {&#10;                ExportFormat.CSV -&gt; exportManager.exportTripToCSV(tripDetails)&#10;                ExportFormat.PDF -&gt; exportManager.exportTripToPDF(tripDetails)&#10;                ExportFormat.EXCEL -&gt; exportManager.exportTripToExcel(tripDetails)&#10;            }&#10;            onComplete(uri)&#10;        }&#10;    }&#10;}&#10;&#10;class TripViewModelFactory(&#10;    private val repository: TripRepository,&#10;    private val context: Context&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(TripViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return TripViewModel(repository, context) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.expensecalculator.TripManager&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.os.Build&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.expensecalculator.Storage.ExportFormat&#10;import com.example.expensecalculator.network.RetrofitClient&#10;import com.example.expensecalculator.repository.ExchangeRateRepository&#10;import com.example.expensecalculator.tripData.CompleteTripDetails&#10;import com.example.expensecalculator.tripData.ExpenseSplit&#10;import com.example.expensecalculator.tripData.ExpenseWithSplits&#10;import com.example.expensecalculator.tripData.SettlementPayment&#10;import com.example.expensecalculator.tripData.Trip&#10;import com.example.expensecalculator.tripData.TripExpense&#10;import com.example.expensecalculator.tripData.TripParticipant&#10;import com.example.expensecalculator.tripData.TripPhoto&#10;import com.example.expensecalculator.util.CurrencyUtils&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;class TripViewModel(&#10;    private val repository: TripRepository,&#10;    context: Context&#10;) : ViewModel() {&#10;&#10;    private val exportManager = TripExportManager(context.applicationContext)&#10;    &#10;    // Exchange rate repository for currency conversion&#10;    private val exchangeRateRepository = ExchangeRateRepository(&#10;        RetrofitClient.exchangeRateApi,&#10;        context.getSharedPreferences(&quot;exchange_rates&quot;, Context.MODE_PRIVATE)&#10;    )&#10;&#10;    // Current exchange rate for display&#10;    private val _currentExchangeRate = MutableStateFlow&lt;Double?&gt;(null)&#10;    val currentExchangeRate: StateFlow&lt;Double?&gt; = _currentExchangeRate.asStateFlow()&#10;&#10;    // Loading state for exchange rate fetch&#10;    private val _isLoadingExchangeRate = MutableStateFlow(false)&#10;    val isLoadingExchangeRate: StateFlow&lt;Boolean&gt; = _isLoadingExchangeRate.asStateFlow()&#10;&#10;    val allTrips = repository.getAllTrips()&#10;&#10;    private val _completeTripDetails = MutableStateFlow&lt;CompleteTripDetails?&gt;(null)&#10;    val completeTripDetails: StateFlow&lt;CompleteTripDetails?&gt; = _completeTripDetails.asStateFlow()&#10;&#10;    val currentTripExpenses: StateFlow&lt;List&lt;TripExpense&gt;&gt; = _completeTripDetails.map {&#10;        it?.expensesWithSplits?.map { expenseWithSplits -&gt; expenseWithSplits.expense } ?: emptyList()&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;    val currentTripParticipants: StateFlow&lt;List&lt;TripParticipant&gt;&gt; = _completeTripDetails.map {&#10;        it?.participants ?: emptyList()&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;&#10;&#10;    val tripBalances: StateFlow&lt;Map&lt;String, Double&gt;&gt; = _completeTripDetails.map { details -&gt;&#10;        if (details == null) {&#10;            emptyMap()&#10;        } else {&#10;            val balances = mutableMapOf&lt;String, Double&gt;()&#10;            // 1. Initialize balances for all participants to 0&#10;            details.participants.forEach { participant -&gt;&#10;                balances[participant.participantName] = 0.0&#10;            }&#10;&#10;            // 2. Process each expense&#10;            details.expensesWithSplits.forEach { expenseWithSplits -&gt;&#10;                val expense = expenseWithSplits.expense&#10;                val paidBy = expense.paidBy&#10;                val totalAmount = expense.amount&#10;&#10;                // Add the full amount to the person who paid&#10;                balances[paidBy] = (balances[paidBy] ?: 0.0) + totalAmount&#10;&#10;                // Subtract each person's share from their balance&#10;                expenseWithSplits.splits.forEach { split -&gt;&#10;                    val participantName = split.participantName&#10;                    val shareAmount = split.shareAmount&#10;                    balances[participantName] = (balances[participantName] ?: 0.0) - shareAmount&#10;                }&#10;            }&#10;            balances&#10;        }&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyMap())&#10;&#10;    // Settlement payments for current trip&#10;    private val _settlementPayments = MutableStateFlow&lt;List&lt;SettlementPayment&gt;&gt;(emptyList())&#10;    val settlementPayments: StateFlow&lt;List&lt;SettlementPayment&gt;&gt; = _settlementPayments.asStateFlow()&#10;&#10;    // Adjusted balances after settlement payments&#10;    val adjustedBalances: StateFlow&lt;Map&lt;String, Double&gt;&gt; = tripBalances.map { baseBalances -&gt;&#10;        val adjusted = baseBalances.toMutableMap()&#10;        _settlementPayments.value.forEach { payment -&gt;&#10;            adjusted[payment.fromParticipant] = (adjusted[payment.fromParticipant] ?: 0.0) + payment.amount&#10;            adjusted[payment.toParticipant] = (adjusted[payment.toParticipant] ?: 0.0) - payment.amount&#10;        }&#10;        adjusted&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyMap())&#10;&#10;    // Optimized settlements calculated from adjusted balances&#10;    val optimizedSettlements: StateFlow&lt;List&lt;Settlement&gt;&gt; = adjustedBalances.map { balances -&gt;&#10;        SettlementOptimizer.calculateOptimizedSettlements(balances)&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;&#10;    fun saveTrip(tripId: Int?, title: String, participantNames: List&lt;String&gt;, tripIconUri: String? = null) {&#10;        viewModelScope.launch {&#10;            if (tripId == null || tripId == -1) {&#10;                repository.addTripWithParticipants(title, participantNames, tripIconUri)&#10;            } else {&#10;                repository.updateTripWithParticipants(tripId, title, participantNames, tripIconUri)&#10;            }&#10;        }&#10;    }&#10;&#10;    //  Update trip icon&#10;    fun updateTripIcon(tripId: Int, iconUri: String) {&#10;        viewModelScope.launch {&#10;            repository.updateTripIcon(tripId, iconUri)&#10;        }&#10;    }&#10;&#10;    suspend fun getTripById(tripId: Int): CompleteTripDetails? {&#10;        return repository.getCompleteTripDetails(tripId)&#10;    }&#10;&#10;    fun deleteTripCompletely(trip: Trip) {&#10;        viewModelScope.launch {&#10;            repository.deleteTripCompletely(trip)&#10;        }&#10;    }&#10;&#10;    fun setCurrentTrip(tripId: Int) {&#10;        viewModelScope.launch {&#10;            repository.getCompleteTripDetailsFlow(tripId).collect { details -&gt;&#10;                _completeTripDetails.value = details&#10;            }&#10;        }&#10;        loadSettlementPayments(tripId)&#10;    }&#10;&#10;    fun clearCurrentTrip() {&#10;        _completeTripDetails.value = null&#10;    }&#10;&#10;    fun addExpense(&#10;        expenseName: String,&#10;        amount: Double,&#10;        paidBy: String,&#10;        participantsInSplit: List&lt;String&gt;&#10;    ) {&#10;        val tripId = _completeTripDetails.value?.trip?.id ?: return&#10;        val currentDate = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;&#10;        viewModelScope.launch {&#10;            val expense = TripExpense(&#10;                tripId = tripId,&#10;                expenseName = expenseName,&#10;                amount = amount,&#10;                paidBy = paidBy,&#10;                date = currentDate&#10;            )&#10;&#10;            val shareAmount = amount / participantsInSplit.size&#10;            val splits = participantsInSplit.map { participantName -&gt;&#10;                ExpenseSplit(&#10;                    expenseId = 0, // This will be set by the DAO&#10;                    participantName = participantName,&#10;                    shareAmount = shareAmount&#10;                )&#10;            }&#10;            repository.addExpenseWithSplits(expense, splits)&#10;        }&#10;    }&#10;&#10;    fun deleteExpense(expense: TripExpense) {&#10;        viewModelScope.launch {&#10;            repository.deleteExpense(expense)&#10;        }&#10;    }&#10;&#10;    fun getExpenseWithSplitsById(expenseId: Int): StateFlow&lt;ExpenseWithSplits?&gt; {&#10;        return repository.getExpenseWithSplitsById(expenseId)&#10;            .stateIn(viewModelScope, SharingStarted.Lazily, null)&#10;    }&#10;&#10;&#10;    val currentTripPhotos: StateFlow&lt;List&lt;TripPhoto&gt;&gt; = _completeTripDetails.map {&#10;        it?.photos ?: emptyList()&#10;    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())&#10;&#10;    fun addPhoto(photoUri: String, caption: String? = null) {&#10;        val tripId = _completeTripDetails.value?.trip?.id ?: return&#10;        viewModelScope.launch {&#10;            val photo = TripPhoto(&#10;                tripId = tripId,&#10;                photoUri = photoUri,&#10;                caption = caption&#10;            )&#10;            repository.addPhoto(photo)&#10;        }&#10;    }&#10;&#10;    fun deletePhoto(photo: TripPhoto) {&#10;        viewModelScope.launch {&#10;            repository.deletePhoto(photo)&#10;        }&#10;    }&#10;&#10;    // SETTLEMENT PAYMENT OPERATIONS&#10;    fun addSettlementPayment(fromParticipant: String, toParticipant: String, amount: Double) {&#10;        val tripId = _completeTripDetails.value?.trip?.id ?: return&#10;        val currentDate = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()).format(Date())&#10;&#10;        viewModelScope.launch {&#10;            val payment = SettlementPayment(&#10;                tripId = tripId,&#10;                fromParticipant = fromParticipant,&#10;                toParticipant = toParticipant,&#10;                amount = amount,&#10;                date = currentDate&#10;            )&#10;            repository.addSettlementPayment(payment)&#10;        }&#10;    }&#10;&#10;    fun deleteSettlementPayment(payment: SettlementPayment) {&#10;        viewModelScope.launch {&#10;            repository.deleteSettlementPayment(payment)&#10;        }&#10;    }&#10;&#10;    private fun loadSettlementPayments(tripId: Int) {&#10;        viewModelScope.launch {&#10;            repository.getSettlementPaymentsByTripId(tripId).collect { payments -&gt;&#10;                _settlementPayments.value = payments&#10;            }&#10;        }&#10;    }&#10;&#10;    // CURRENCY OPERATIONS&#10;    /**&#10;     * Get exchange rate between two currencies&#10;     */&#10;    fun getExchangeRate(fromCurrency: String, toCurrency: String, onResult: (Double?) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            _isLoadingExchangeRate.value = true&#10;            try {&#10;                val rate = exchangeRateRepository.getRate(fromCurrency, toCurrency)&#10;                _currentExchangeRate.value = rate&#10;                onResult(rate)&#10;            } catch (e: Exception) {&#10;                _currentExchangeRate.value = null&#10;                onResult(null)&#10;            } finally {&#10;                _isLoadingExchangeRate.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update trip currency&#10;     */&#10;    fun updateTripCurrency(tripId: Int, currency: String) {&#10;        viewModelScope.launch {&#10;            repository.updateTripCurrency(tripId, currency)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format amount with trip's currency&#10;     */&#10;    fun formatAmount(amount: Double): String {&#10;        val currency = _completeTripDetails.value?.trip?.currency ?: &quot;INR&quot;&#10;        return CurrencyUtils.format(amount, currency)&#10;    }&#10;&#10;    /**&#10;     * Refresh exchange rates for current trip currency&#10;     */&#10;    fun refreshExchangeRates(onComplete: (Boolean) -&gt; Unit) {&#10;        val currency = _completeTripDetails.value?.trip?.currency ?: &quot;INR&quot;&#10;        viewModelScope.launch {&#10;            try {&#10;                exchangeRateRepository.refreshRates(currency)&#10;                onComplete(true)&#10;            } catch (e: Exception) {&#10;                onComplete(false)&#10;            }&#10;        }&#10;    }&#10;&#10;    //EXPORT OPERATIONS&#10;    fun exportTrip(format: ExportFormat, onComplete: (Uri?) -&gt; Unit) {&#10;        // Check if Android version supports the export functionality&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) {&#10;            onComplete(null)&#10;            return&#10;        }&#10;&#10;        val tripDetails = _completeTripDetails.value ?: run {&#10;            onComplete(null)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            val uri = when (format) {&#10;                ExportFormat.CSV -&gt; exportManager.exportTripToCSV(tripDetails)&#10;                ExportFormat.PDF -&gt; exportManager.exportTripToPDF(tripDetails)&#10;                ExportFormat.EXCEL -&gt; exportManager.exportTripToExcel(tripDetails)&#10;            }&#10;            onComplete(uri)&#10;        }&#10;    }&#10;}&#10;&#10;class TripViewModelFactory(&#10;    private val repository: TripRepository,&#10;    private val context: Context&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(TripViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return TripViewModel(repository, context) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/TripManager/CurrencySelectionDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/TripManager/CurrencySelectionDialog.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.TripManager&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.example.expensecalculator.util.CurrencyCode&#10;&#10;/**&#10; * Dialog for selecting currency for a trip&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun CurrencySelectionDialog(&#10;    currentCurrency: String,&#10;    onDismiss: () -&gt; Unit,&#10;    onCurrencySelected: (String) -&gt; Unit&#10;) {&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = {&#10;            Text(&#10;                &quot;Select Currency&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        },&#10;        text = {&#10;            LazyColumn(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                items(CurrencyCode.values()) { currency -&gt;&#10;                    CurrencyItem(&#10;                        currency = currency,&#10;                        isSelected = currentCurrency == currency.code,&#10;                        onClick = {&#10;                            onCurrencySelected(currency.code)&#10;                            onDismiss()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;Cancel&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun CurrencyItem(&#10;    currency: CurrencyCode,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (isSelected)&#10;                MaterialTheme.colorScheme.primaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = currency.symbol,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Column {&#10;                    Text(&#10;                        text = currency.displayName,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.Medium&#10;                    )&#10;                    Text(&#10;                        text = currency.code,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                    )&#10;                }&#10;            }&#10;            if (isSelected) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Check,&#10;                    contentDescription = &quot;Selected&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Compact currency display chip&#10; */&#10;@Composable&#10;fun CurrencyChip(&#10;    currency: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val currencyCode = CurrencyCode.fromCode(currency)&#10;    &#10;    AssistChip(&#10;        onClick = onClick,&#10;        label = {&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(currencyCode.symbol)&#10;                Text(currencyCode.code)&#10;            }&#10;        },&#10;        modifier = modifier&#10;    )&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/network/ExchangeRateApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/network/ExchangeRateApi.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.network&#10;&#10;import retrofit2.http.GET&#10;import retrofit2.http.Query&#10;&#10;interface ExchangeRateApi {&#10;    /**&#10;     * Get latest exchange rates from base currency&#10;     * Example: GET https://api.exchangerate.host/latest?base=USD&#10;     */&#10;    @GET(&quot;latest&quot;)&#10;    suspend fun getLatestRates(@Query(&quot;base&quot;) baseCurrency: String): ExchangeRateResponse&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/network/ExchangeRateResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/network/ExchangeRateResponse.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.network&#10;&#10;import com.squareup.moshi.Json&#10;import com.squareup.moshi.JsonClass&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class ExchangeRateResponse(&#10;    @Json(name = &quot;base&quot;)&#10;    val baseCurrency: String,&#10;    @Json(name = &quot;date&quot;)&#10;    val date: String,&#10;    @Json(name = &quot;rates&quot;)&#10;    val rates: Map&lt;String, Double&gt;,&#10;    @Json(name = &quot;success&quot;)&#10;    val success: Boolean = true&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/network/RetrofitClient.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/network/RetrofitClient.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.network&#10;&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.moshi.MoshiConverterFactory&#10;import com.squareup.moshi.Moshi&#10;import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory&#10;&#10;object RetrofitClient {&#10;    private const val BASE_URL = &quot;https://api.exchangerate.host/&quot;&#10;&#10;    private val moshi = Moshi.Builder()&#10;        .add(KotlinJsonAdapterFactory())&#10;        .build()&#10;&#10;    private val retrofit = Retrofit.Builder()&#10;        .baseUrl(BASE_URL)&#10;        .addConverterFactory(MoshiConverterFactory.create(moshi))&#10;        .build()&#10;&#10;    val exchangeRateApi: ExchangeRateApi by lazy {&#10;        retrofit.create(ExchangeRateApi::class.java)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/repository/ExchangeRateRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/repository/ExchangeRateRepository.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.repository&#10;&#10;import android.content.SharedPreferences&#10;import com.example.expensecalculator.network.ExchangeRateApi&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;&#10;class ExchangeRateRepository(&#10;    private val api: ExchangeRateApi,&#10;    private val prefs: SharedPreferences&#10;) {&#10;    private val CACHE_TTL_MS = TimeUnit.HOURS.toMillis(24)&#10;&#10;    private fun cacheKey(base: String, target: String) = &quot;rate_${base}_$target&quot;&#10;    private fun timestampKey(base: String, target: String) = &quot;ts_${base}_$target&quot;&#10;&#10;    /**&#10;     * Get exchange rate from base to target currency&#10;     * Uses cached rate if available and not stale (&lt; 24 hours old)&#10;     * Otherwise fetches from API and caches the result&#10;     */&#10;    suspend fun getRate(baseCurrency: String, targetCurrency: String): Double = withContext(Dispatchers.IO) {&#10;        // Same currency = 1.0&#10;        if (baseCurrency == targetCurrency) return@withContext 1.0&#10;&#10;        val key = cacheKey(baseCurrency, targetCurrency)&#10;        val tsKey = timestampKey(baseCurrency, targetCurrency)&#10;&#10;        // Check cache&#10;        val cachedRate = prefs.getString(key, null)?.toDoubleOrNull()&#10;        val cachedTimestamp = prefs.getLong(tsKey, 0L)&#10;        val now = System.currentTimeMillis()&#10;&#10;        if (cachedRate != null &amp;&amp; (now - cachedTimestamp) &lt; CACHE_TTL_MS) {&#10;            return@withContext cachedRate&#10;        }&#10;&#10;        // Fetch from network&#10;        try {&#10;            val response = api.getLatestRates(baseCurrency)&#10;            val rate = response.rates[targetCurrency] &#10;                ?: throw IllegalArgumentException(&quot;No rate found for $targetCurrency&quot;)&#10;&#10;            // Cache the result&#10;            prefs.edit().apply {&#10;                putString(key, rate.toString())&#10;                putLong(tsKey, now)&#10;                apply()&#10;            }&#10;&#10;            return@withContext rate&#10;        } catch (e: Exception) {&#10;            // If network fails and we have cached data, use it even if stale&#10;            if (cachedRate != null) {&#10;                return@withContext cachedRate&#10;            }&#10;            throw e&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh all rates for a given base currency&#10;     */&#10;    suspend fun refreshRates(baseCurrency: String): Map&lt;String, Double&gt; = withContext(Dispatchers.IO) {&#10;        val response = api.getLatestRates(baseCurrency)&#10;        val now = System.currentTimeMillis()&#10;&#10;        // Cache all rates&#10;        prefs.edit().apply {&#10;            response.rates.forEach { (target, rate) -&gt;&#10;                putString(cacheKey(baseCurrency, target), rate.toString())&#10;                putLong(timestampKey(baseCurrency, target), now)&#10;            }&#10;            apply()&#10;        }&#10;&#10;        return@withContext response.rates&#10;    }&#10;&#10;    /**&#10;     * Clear all cached rates&#10;     */&#10;    fun clearCache() {&#10;        prefs.edit().clear().apply()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/tripData/16_tripData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/tripData/16_tripData.kt" />
              <option name="originalContent" value="package com.example.expensecalculator.tripData&#10;&#10;import androidx.room.Embedded&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.PrimaryKey&#10;import androidx.room.Relation&#10;&#10;&#10;@Entity(tableName = &quot;trips&quot;)&#10;data class Trip(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val title: String,&#10;    val days: Int? = null,&#10;    val expenditure: Double? = null,&#10;    val tripIconUri: String? = null&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;trip_participants&quot;,&#10;    foreignKeys = [ForeignKey(entity = Trip::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;tripId&quot;], onDelete = ForeignKey.CASCADE)]&#10;)&#10;data class TripParticipant(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val tripId: Int,&#10;    val participantName: String,&#10;    val contactNumber: String? = null,&#10;    val email: String? = null&#10;)&#10;&#10;&#10;@Entity(&#10;    tableName = &quot;tripExpense&quot;,&#10;    foreignKeys = [ForeignKey(entity = Trip::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;tripId&quot;], onDelete = ForeignKey.CASCADE)]&#10;)&#10;data class TripExpense(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val tripId: Int,&#10;    val expenseName: String,&#10;    val amount: Double,&#10;    val paidBy: String, // The name of the participant who paid&#10;    val date: String? = null,&#10;    val splitType: String = &quot;EQUALLY&quot;&#10;)&#10;&#10;// This is the crucial new table to track splits&#10;@Entity(&#10;    tableName = &quot;expense_splits&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(entity = TripExpense::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;expenseId&quot;], onDelete = ForeignKey.CASCADE)&#10;    ]&#10;)&#10;data class ExpenseSplit(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val expenseId: Int, // Links this split to a specific expense&#10;    val participantName: String, // The name of the person who has a share in this expense&#10;    val shareAmount: Double // The amount of this person's share&#10;)&#10;&#10;//  For storing trip photos&#10;@Entity(&#10;    tableName = &quot;trip_photos&quot;,&#10;    foreignKeys = [ForeignKey(entity = Trip::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;tripId&quot;], onDelete = ForeignKey.CASCADE)]&#10;)&#10;data class TripPhoto(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val tripId: Int,&#10;    val photoUri: String, // URI/path to the photo&#10;    val caption: String? = null,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;// Helper class to bundle an expense with its splits&#10;data class ExpenseWithSplits(&#10;    @Embedded val expense: TripExpense,&#10;    @Relation(&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;expenseId&quot;&#10;    )&#10;    val splits: List&lt;ExpenseSplit&gt;&#10;)&#10;&#10;&#10;data class CompleteTripDetails(&#10;    @Embedded val trip: Trip,&#10;    @Relation(&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;tripId&quot;&#10;    )&#10;    val participants: List&lt;TripParticipant&gt;,&#10;    @Relation(&#10;        entity = TripExpense::class,&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;tripId&quot;&#10;    )&#10;    val expensesWithSplits: List&lt;ExpenseWithSplits&gt;,&#10;    @Relation(&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;tripId&quot;&#10;    )&#10;    val photos: List&lt;TripPhoto&gt; = emptyList()&#10;)" />
              <option name="updatedContent" value="package com.example.expensecalculator.tripData&#10;&#10;import androidx.room.Embedded&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.PrimaryKey&#10;import androidx.room.Relation&#10;&#10;&#10;@Entity(tableName = &quot;trips&quot;)&#10;data class Trip(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val title: String,&#10;    val days: Int? = null,&#10;    val expenditure: Double? = null,&#10;    val tripIconUri: String? = null,&#10;    val currency: String = &quot;INR&quot; // Base currency for the trip (ISO code)&#10;)&#10;&#10;@Entity(&#10;    tableName = &quot;trip_participants&quot;,&#10;    foreignKeys = [ForeignKey(entity = Trip::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;tripId&quot;], onDelete = ForeignKey.CASCADE)]&#10;)&#10;data class TripParticipant(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val tripId: Int,&#10;    val participantName: String,&#10;    val contactNumber: String? = null,&#10;    val email: String? = null&#10;)&#10;&#10;&#10;@Entity(&#10;    tableName = &quot;tripExpense&quot;,&#10;    foreignKeys = [ForeignKey(entity = Trip::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;tripId&quot;], onDelete = ForeignKey.CASCADE)]&#10;)&#10;data class TripExpense(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val tripId: Int,&#10;    val expenseName: String,&#10;    val amount: Double,&#10;    val paidBy: String, // The name of the participant who paid&#10;    val date: String? = null,&#10;    val splitType: String = &quot;EQUALLY&quot;&#10;)&#10;&#10;// This is the crucial new table to track splits&#10;@Entity(&#10;    tableName = &quot;expense_splits&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(entity = TripExpense::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;expenseId&quot;], onDelete = ForeignKey.CASCADE)&#10;    ]&#10;)&#10;data class ExpenseSplit(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val expenseId: Int, // Links this split to a specific expense&#10;    val participantName: String, // The name of the person who has a share in this expense&#10;    val shareAmount: Double // The amount of this person's share&#10;)&#10;&#10;//  For storing trip photos&#10;@Entity(&#10;    tableName = &quot;trip_photos&quot;,&#10;    foreignKeys = [ForeignKey(entity = Trip::class, parentColumns = [&quot;id&quot;], childColumns = [&quot;tripId&quot;], onDelete = ForeignKey.CASCADE)]&#10;)&#10;data class TripPhoto(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Int = 0,&#10;    val tripId: Int,&#10;    val photoUri: String, // URI/path to the photo&#10;    val caption: String? = null,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;// Helper class to bundle an expense with its splits&#10;data class ExpenseWithSplits(&#10;    @Embedded val expense: TripExpense,&#10;    @Relation(&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;expenseId&quot;&#10;    )&#10;    val splits: List&lt;ExpenseSplit&gt;&#10;)&#10;&#10;&#10;data class CompleteTripDetails(&#10;    @Embedded val trip: Trip,&#10;    @Relation(&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;tripId&quot;&#10;    )&#10;    val participants: List&lt;TripParticipant&gt;,&#10;    @Relation(&#10;        entity = TripExpense::class,&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;tripId&quot;&#10;    )&#10;    val expensesWithSplits: List&lt;ExpenseWithSplits&gt;,&#10;    @Relation(&#10;        parentColumn = &quot;id&quot;,&#10;        entityColumn = &quot;tripId&quot;&#10;    )&#10;    val photos: List&lt;TripPhoto&gt; = emptyList()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/tripData/17_TripDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/tripData/17_TripDao.kt" />
              <option name="originalContent" value="package com.example.expensecalculator.tripData&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface TripDao {&#10;&#10;&#10;    @Insert&#10;    suspend fun addTrip(trip: Trip): Long&#10;    @Update&#10;    suspend fun updateTrip(trip: Trip)&#10;    @Delete&#10;    suspend fun deleteTrip(trip: Trip)&#10;    @Query(&quot;SELECT * FROM trips ORDER BY id DESC&quot;)&#10;    fun showAllTrips(): Flow&lt;List&lt;Trip&gt;&gt;&#10;&#10;    @Insert&#10;    suspend fun addParticipants(participants: List&lt;TripParticipant&gt;)&#10;    @Query(&quot;DELETE FROM trip_participants WHERE tripId = :tripId&quot;)&#10;    suspend fun deleteAllParticipantsForTrip(tripId: Int)&#10;&#10;&#10;    @Insert&#10;    suspend fun addExpense(expense: TripExpense): Long&#10;&#10;    @Delete&#10;    suspend fun deleteExpense(expense: TripExpense)&#10;&#10;    @Insert&#10;    suspend fun addSplits(splits: List&lt;ExpenseSplit&gt;)&#10;&#10;    @Query(&quot;SELECT * FROM tripExpense WHERE tripId = :tripId ORDER BY id DESC&quot;)&#10;    fun getExpensesByTripIdFlow(tripId: Int): Flow&lt;List&lt;TripExpense&gt;&gt;&#10;&#10;&#10;    @Transaction&#10;    @Query(&quot;SELECT * FROM tripExpense WHERE id = :expenseId&quot;)&#10;    fun getExpenseWithSplitsByIdFlow(expenseId: Int): Flow&lt;ExpenseWithSplits?&gt;&#10;&#10;&#10;    @Transaction&#10;    @Query(&quot;SELECT * FROM trips WHERE id = :tripId&quot;)&#10;    suspend fun getCompleteTripDetails(tripId: Int): CompleteTripDetails?&#10;&#10;    @Transaction&#10;    @Query(&quot;SELECT * FROM trips WHERE id = :tripId&quot;)&#10;    fun getCompleteTripDetailsFlow(tripId: Int): Flow&lt;CompleteTripDetails?&gt;&#10;&#10;&#10;    @Transaction&#10;    suspend fun addTripWithParticipants(trip: Trip, participantNames: List&lt;String&gt;) {&#10;        val tripId = addTrip(trip)&#10;        val participants = participantNames.map { name -&gt;&#10;            TripParticipant(tripId = tripId.toInt(), participantName = name)&#10;        }&#10;        addParticipants(participants)&#10;    }&#10;&#10;    @Transaction&#10;    suspend fun updateTripWithParticipants(trip: Trip, participantNames: List&lt;String&gt;) {&#10;        updateTrip(trip)&#10;        deleteAllParticipantsForTrip(trip.id)&#10;        val newParticipants = participantNames.map { name -&gt;&#10;            TripParticipant(tripId = trip.id, participantName = name)&#10;        }&#10;        addParticipants(newParticipants)&#10;    }&#10;&#10;    @Transaction&#10;    suspend fun addExpenseWithSplits(expense: TripExpense, splits: List&lt;ExpenseSplit&gt;) {&#10;        val expenseId = addExpense(expense)&#10;        val splitsWithExpenseId = splits.map { it.copy(expenseId = expenseId.toInt()) }&#10;        addSplits(splitsWithExpenseId)&#10;    }&#10;&#10;    @Transaction&#10;    suspend fun deleteTripCompletely(trip: Trip) {&#10;        deleteTrip(trip)&#10;    }&#10;&#10;    @Insert&#10;    suspend fun addPhoto(photo: TripPhoto): Long&#10;&#10;    @Delete&#10;    suspend fun deletePhoto(photo: TripPhoto)&#10;&#10;    @Query(&quot;SELECT * FROM trip_photos WHERE tripId = :tripId ORDER BY timestamp DESC&quot;)&#10;    fun getPhotosByTripIdFlow(tripId: Int): Flow&lt;List&lt;TripPhoto&gt;&gt;&#10;&#10;    // Settlement Payment operations&#10;    @Insert&#10;    suspend fun addSettlementPayment(payment: SettlementPayment): Long&#10;&#10;    @Query(&quot;SELECT * FROM settlement_payments WHERE tripId = :tripId ORDER BY timestamp DESC&quot;)&#10;    fun getSettlementPaymentsByTripIdFlow(tripId: Int): Flow&lt;List&lt;SettlementPayment&gt;&gt;&#10;&#10;    @Query(&quot;DELETE FROM settlement_payments WHERE tripId = :tripId&quot;)&#10;    suspend fun deleteAllSettlementPaymentsForTrip(tripId: Int)&#10;&#10;    @Delete&#10;    suspend fun deleteSettlementPayment(payment: SettlementPayment)&#10;}" />
              <option name="updatedContent" value="package com.example.expensecalculator.tripData&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface TripDao {&#10;&#10;&#10;    @Insert&#10;    suspend fun addTrip(trip: Trip): Long&#10;    @Update&#10;    suspend fun updateTrip(trip: Trip)&#10;    @Delete&#10;    suspend fun deleteTrip(trip: Trip)&#10;    @Query(&quot;SELECT * FROM trips ORDER BY id DESC&quot;)&#10;    fun showAllTrips(): Flow&lt;List&lt;Trip&gt;&gt;&#10;&#10;    @Insert&#10;    suspend fun addParticipants(participants: List&lt;TripParticipant&gt;)&#10;    @Query(&quot;DELETE FROM trip_participants WHERE tripId = :tripId&quot;)&#10;    suspend fun deleteAllParticipantsForTrip(tripId: Int)&#10;&#10;&#10;    @Insert&#10;    suspend fun addExpense(expense: TripExpense): Long&#10;&#10;    @Delete&#10;    suspend fun deleteExpense(expense: TripExpense)&#10;&#10;    @Insert&#10;    suspend fun addSplits(splits: List&lt;ExpenseSplit&gt;)&#10;&#10;    @Query(&quot;SELECT * FROM tripExpense WHERE tripId = :tripId ORDER BY id DESC&quot;)&#10;    fun getExpensesByTripIdFlow(tripId: Int): Flow&lt;List&lt;TripExpense&gt;&gt;&#10;&#10;&#10;    @Transaction&#10;    @Query(&quot;SELECT * FROM tripExpense WHERE id = :expenseId&quot;)&#10;    fun getExpenseWithSplitsByIdFlow(expenseId: Int): Flow&lt;ExpenseWithSplits?&gt;&#10;&#10;&#10;    @Transaction&#10;    @Query(&quot;SELECT * FROM trips WHERE id = :tripId&quot;)&#10;    suspend fun getCompleteTripDetails(tripId: Int): CompleteTripDetails?&#10;&#10;    @Transaction&#10;    @Query(&quot;SELECT * FROM trips WHERE id = :tripId&quot;)&#10;    fun getCompleteTripDetailsFlow(tripId: Int): Flow&lt;CompleteTripDetails?&gt;&#10;&#10;&#10;    @Transaction&#10;    suspend fun addTripWithParticipants(trip: Trip, participantNames: List&lt;String&gt;) {&#10;        val tripId = addTrip(trip)&#10;        val participants = participantNames.map { name -&gt;&#10;            TripParticipant(tripId = tripId.toInt(), participantName = name)&#10;        }&#10;        addParticipants(participants)&#10;    }&#10;&#10;    @Transaction&#10;    suspend fun updateTripWithParticipants(trip: Trip, participantNames: List&lt;String&gt;) {&#10;        updateTrip(trip)&#10;        deleteAllParticipantsForTrip(trip.id)&#10;        val newParticipants = participantNames.map { name -&gt;&#10;            TripParticipant(tripId = trip.id, participantName = name)&#10;        }&#10;        addParticipants(newParticipants)&#10;    }&#10;&#10;    @Transaction&#10;    suspend fun addExpenseWithSplits(expense: TripExpense, splits: List&lt;ExpenseSplit&gt;) {&#10;        val expenseId = addExpense(expense)&#10;        val splitsWithExpenseId = splits.map { it.copy(expenseId = expenseId.toInt()) }&#10;        addSplits(splitsWithExpenseId)&#10;    }&#10;&#10;    @Transaction&#10;    suspend fun deleteTripCompletely(trip: Trip) {&#10;        deleteTrip(trip)&#10;    }&#10;&#10;    @Insert&#10;    suspend fun addPhoto(photo: TripPhoto): Long&#10;&#10;    @Delete&#10;    suspend fun deletePhoto(photo: TripPhoto)&#10;&#10;    @Query(&quot;SELECT * FROM trip_photos WHERE tripId = :tripId ORDER BY timestamp DESC&quot;)&#10;    fun getPhotosByTripIdFlow(tripId: Int): Flow&lt;List&lt;TripPhoto&gt;&gt;&#10;&#10;    // Settlement Payment operations&#10;    @Insert&#10;    suspend fun addSettlementPayment(payment: SettlementPayment): Long&#10;&#10;    @Query(&quot;SELECT * FROM settlement_payments WHERE tripId = :tripId ORDER BY timestamp DESC&quot;)&#10;    fun getSettlementPaymentsByTripIdFlow(tripId: Int): Flow&lt;List&lt;SettlementPayment&gt;&gt;&#10;&#10;    @Query(&quot;DELETE FROM settlement_payments WHERE tripId = :tripId&quot;)&#10;    suspend fun deleteAllSettlementPaymentsForTrip(tripId: Int)&#10;&#10;    @Delete&#10;    suspend fun deleteSettlementPayment(payment: SettlementPayment)&#10;&#10;    // Currency operations&#10;    @Query(&quot;UPDATE trips SET currency = :currency WHERE id = :tripId&quot;)&#10;    suspend fun updateTripCurrency(tripId: Int, currency: String)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/util/CurrencyCode.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/util/CurrencyCode.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.util&#10;&#10;enum class CurrencyCode(val code: String, val symbol: String, val displayName: String) {&#10;    INR(&quot;INR&quot;, &quot;&quot;, &quot;Indian Rupee&quot;),&#10;    USD(&quot;USD&quot;, &quot;$&quot;, &quot;US Dollar&quot;),&#10;    EUR(&quot;EUR&quot;, &quot;&quot;, &quot;Euro&quot;),&#10;    GBP(&quot;GBP&quot;, &quot;&quot;, &quot;British Pound&quot;),&#10;    JPY(&quot;JPY&quot;, &quot;&quot;, &quot;Japanese Yen&quot;),&#10;    AUD(&quot;AUD&quot;, &quot;A$&quot;, &quot;Australian Dollar&quot;),&#10;    CAD(&quot;CAD&quot;, &quot;C$&quot;, &quot;Canadian Dollar&quot;),&#10;    CHF(&quot;CHF&quot;, &quot;Fr&quot;, &quot;Swiss Franc&quot;),&#10;    CNY(&quot;CNY&quot;, &quot;&quot;, &quot;Chinese Yuan&quot;),&#10;    AED(&quot;AED&quot;, &quot;.&quot;, &quot;UAE Dirham&quot;);&#10;&#10;    override fun toString(): String = &quot;$symbol $displayName ($code)&quot;&#10;    &#10;    companion object {&#10;        fun fromCode(code: String): CurrencyCode {&#10;            return values().find { it.code == code } ?: INR&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/util/CurrencyUtils.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/expensecalculator/util/CurrencyUtils.kt" />
              <option name="updatedContent" value="package com.example.expensecalculator.util&#10;&#10;import java.math.BigDecimal&#10;import java.math.RoundingMode&#10;import java.text.NumberFormat&#10;import java.util.Currency&#10;import java.util.Locale&#10;&#10;object CurrencyUtils {&#10;    /**&#10;     * Convert amount from one currency to another using exchange rate&#10;     */&#10;    fun convert(amount: Double, rate: Double, scale: Int = 2): Double {&#10;        return BigDecimal.valueOf(amount)&#10;            .multiply(BigDecimal.valueOf(rate))&#10;            .setScale(scale, RoundingMode.HALF_UP)&#10;            .toDouble()&#10;    }&#10;&#10;    /**&#10;     * Format amount with currency symbol&#10;     */&#10;    fun format(amount: Double, currencyCode: String): String {&#10;        val currency = CurrencyCode.fromCode(currencyCode)&#10;        return &quot;${currency.symbol}${&quot;%.2f&quot;.format(amount)}&quot;&#10;    }&#10;&#10;    /**&#10;     * Format amount with locale-specific formatting&#10;     */&#10;    fun formatWithLocale(amount: Double, currencyCode: String, locale: Locale = Locale.getDefault()): String {&#10;        val nf = NumberFormat.getCurrencyInstance(locale)&#10;        try {&#10;            nf.currency = Currency.getInstance(currencyCode)&#10;        } catch (_: Exception) {&#10;            // Fallback to manual formatting&#10;            return format(amount, currencyCode)&#10;        }&#10;        return nf.format(amount)&#10;    }&#10;&#10;    /**&#10;     * Get symbol for currency code&#10;     */&#10;    fun getSymbol(currencyCode: String): String {&#10;        return CurrencyCode.fromCode(currencyCode).symbol&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>